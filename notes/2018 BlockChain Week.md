# 2018 BlockChain Week (18/10/25)

## Session 1. 블록체인 개론

### 1. 물리적인 화폐와 디지털 자산

1. 물리적 화폐는 물리적인 위치를 이동시켜 소유권 이동 가능
2. 디지털 자산은 불가능
   1. Why? 디지털 데이터를 복사해서 이동하는데, 원래 저장소에 삭제를 강제할 수 없음.
   2. ==> 신뢰할 수 있는 중개자가 필요함.

1. 전자서명
   1. 디지털 자산의 소유자만이 자산을 이동(= 트랜잭션 발생)할 수 있도록 함.
   2. by. 공개키 암호화.
      1. 해시함수 -> 트랜잭션 해시값 구함
      2. 해시값을 비밀키로 => 서명 만듬 => 트랜잭션과 함께 전출
      3. 트랜잭션 받은 주체는, 같은 해시함수를 사용해서, 트랜잭션의 해시값을 구하고, 전자서명을 공개키로 복호화.
      4. 두 값을 비교하여, 사용자 신원을 알아냄 
   3. 문제점 : 이중지불문제

### 2. 이중지불문제

1. 원인 : 전자서명이 한 사람이 여러 개의 모순된 트랜잭션을 발생시키는 것을 막을 수 없어서 생기는 문제.
2. 해결 : 모순된 트랜잭션들 중, 맨 처음꺼 하나만 선택하고, 나머지를 무효화시킨다. (by. 신뢰주체)
   1. 맨 처음껄 어케 알까?
      1. 네트워크 딜레이땜에 먼저 발생한거 찾기가 힘듬
      2. 지금은 신뢰주체에게 먼저 도달한 것으로 채택.

### 3. 신뢰와 존재의 문제

1. **문제**
   1. **신뢰 주체를 신뢰할 수 있는가?**
   2. **신뢰할 수 있는 주체가 존재하는가?**

2. **신뢰 주체 없이 디지털 자산을 이동시키는 방법 (=> 블록체인)**
   1. P2P 네트워크
      - 중앙 집중식 관리 시스템을 사용하지 않고, 상호 연결된 노드들이 서로 간에 자원을 공유하는 네트워크
      - 노드 간 계층이 없으므로 노드의 참여와 떠남이 자유로움
      - 임의의 디지털 형식 파일 공유에 보편적으로 사용된다
   2. 분산 원장(Distributed Ledger)
     - 신뢰 주체 대신에 P2P 네트워크를 구축하고 모든 참여자들이 트랜잭션을 저장 및 공유하도록 하는 아이디어
     - 트랜잭션의 합이 최종적인 디지털 자산 분배의 상태이므로 프로그램 상태는 따로 저장하지 않는 것이 비트코인의 모델

### 4. 합의 알고리즘

P2P에서 트랜잭션의 순서를 결정하는 방법 (+트랜잭션 유효성 증명)

이렇게 순서를 결정하는 방법에 대하여 네트워크 참여자들이 합의하는 규칙을 합의 알고리즘이라 함

	#### 1. 작업 증명 (Proof of Work)

 - 컴퓨팅 파워와 시간이 필요한 **작업 증명을 완료한 노드**에게 <u>트랜잭션들의 순서</u>를 결정할 **권한을 부여**한다
  - 이때 트랜잭션들의 <u>유효성을 검증</u>하고 <u>이전 블록의 해시값을 포함</u>하여 블록으로 만들어 **순서**를 정하고 전파한다
  - 그리고 작업 증명을 유도하기 위하여 블록을 만든 노드에게 <u>일정량의 디지털 자산이 보상</u>으로 지급된다.

#### 2. 지분 증명 (Proof of Stake)

- 디지털 자산이 많은 노드에 트랜잭션 순서를 결정할 권한을 부여한다

#### 3. 가십 프로토콜 (초기 모델)

1. 대역폭의 낭비를 줄이면서도 빠르게 데이터를 전파하기 위한 방법
2. A가 몇명한테 넘기고, 받은 애들이 또 다른애들한테 넘기는 식으로 전파.
3. 전염병 프토토콜이라고도 함.
4. 단방향으로 Tree 형태로 전송하는 형태
   1. 단점: 중간에 끊기면, 걔랑 이어진 애들은 다 못받음.
   2. 해결: (조금 비효율적이더라도) 서로 이어지게 만듬

#### 4. 나카모토 컨센서스

 	1. 체인 선택 규칙
     - 배경 : 블록 및 트랜잭션은 가십프로토콜로 전파 -> 시간 걸림 -> 포크된 블록들을 받았을 때, **순서를 가리기 힘듬**
     - **순서 선택 방법** (싱크 맞추기)
       - 블록 생성 시, 해당 블록의 해시값에 이전 블록의 해시값을 포함시킴 
         - -> 순서를 알 수 있음.
 	2. 비트코인의 합의 알고리즘

### 5. DAG (Directed cyclic Graph) 자료구조

사이클이 없는 단방향의 그래프

#### 1. 비동기적인 블록체인 구현 방식

먼저 발생한 트랜잭션들 중 일부를 선택하여, 이어지는 트랜잭션 발생 -> 부분적으로 순서를 정함

- ![dag ë¸ë¡ì²´ì¸ì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://www.iotakorea.net/wp-content/uploads/2017/08/IMG_7246.jpg)
- ![dagì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://cdn-images-1.medium.com/max/350/1*U_0kAewGCLy1XwSnmBzjjA.png)

-  블록이 생길 때, 이전 블록을 검증하고(최대 2개), 이를 부모로 두게 함. 
- 잘 이용되진 않음
  - why?
    - 같은 깊이인 B, C 블록이 서로 모순된다면? (더블스펜딩)
    - B, C의 순서를 정할 수 없다는 이슈.

## Session 2. 예제로 배우는 스마트 컨트랙트

### 1. 스마트 컨트랙트의 기초

#### 1. 트랜잭션의 확장

1. 프로그램 상태의 전이
   - 프로그램은 명령어에 의해 상태가 변경된다
   - 트랜잭션에 의해 디지털 자산이 소유권에 해당하는 데이터가 변경되는 것은 크게 보면 소유권 데이터를 처리하는 프로그램 상태가 변경되는 것과 유사하다
   - 트랜잭션 : 상태의 전이.
   - 이를 확장시킨다면 트랜잭션을 디지털 자산의 이동 뿐만 아니라 일반적인 프로그램의 상태 변경에도 사용할 수 있지 않을까?
2. 스마트 컨트랙트 :: 일반적인 프로그램
  - 위 아이디어는 비탈릭 부테린과 가빈 우드에 의해 이더리움으로 구현되었다.
  - 트랜잭션은 명령어, 그 중에서도 특히 <u>여러 명령어를 실행하는</u> **함수 호출 명령어**에 대응된다
  - 일반적인 프로그램은 실행해보기 전에 종료가 될지 안될 지 알 수 없다 (무한루프 가능성)
  - => 이더리움은 프로그램의 <u>각 명령어에 비용을 부과</u>함으로써 **종료를 보장**하였다.
3. UTSO : 사용되지 않은 트랜잭션?
   1. if 잔고가 100이라면 ? 
      1. 지갑 A에 10, B에 40, C에 50이 있는 상태
      2. 다른애한테 5를 보낼라 그럼
      3. A에서 5를 보내겠지?
      4. UTSO 있나 모든 지갑에 다 물어보고 일일이 잔고 계산해서 진행함? 
         1. ==> 불편하니까, 통합하자. (==> 이더리움)

#### 2. 이더리움 가상 머신 (EVM)

이더리움의 범용성을 위해 만들어짐.

1. 가상머신의 필요성
   - 각 명령어에 비용을 부과하기 위해서 <u>명령어를 실행</u>하면서 <u>비용을 저장하고 누적</u>시키는 또 다른 프로그램이 필요하다
   - 보통 프로그램은 운영 체제 및 마이크로프로세서가 실행시키기 때문에 운영체제나 프로세서 *아키텍처를 바꾸어야*  명령어에 비용을 부과할 수 있음
   - 이렇게 되면 해당 프로세서와 운영체제를 가지고 있는 사람만 블록체인 네트워크에 참여할 수 있으므로 누구나 참여 가능하도록 하는 p2p 네트워크 정신에 위배된다(<u>이식성이 감소</u>)
   - 따라서 프로그램을 실행하는 프로그램인 **가상 머신 위에서 스마트 컨트랙트를 실행**해야 한다
   - <u>가상 머신은 프로그램이니까, 거기에 가스를 누적시킬 수 있고, 가스비를 계산할 수 있다.</u>
   - 일반적으로 가상 머신은 이식성이 높은 환경을 제공하고 약타입 언어를 위한 타입 추론이나 자동 메모리 기법인 가비지 컬렉션, 그리고 런타임 프로파일을 이용한 동적 최적화 등을 제공하는 언어를 위해서 사용된다
   - Java, Javascript, Python, Go

2. 이더리움 가상 머신
   1. 중간언어인 바이트코드를 지원.
   2. 스마트 컨트랙트 작성 언어 : Solidity, Serpent, ... 
      1. 얘네를 이더리움 바이트코드로 바꿀 수 있으면, 스마트 컨트랙트 작성 가능.

#### 3. 코드의 특징

- 앞에서 말했듯이, 트랜잭션은 스마트 컨트랙트의 명령어셋, 즉 함수를 실행시킨다
- 따라서 스마트 컨트랙트의 실행은 절차적이지않고 데몬으로 동작하지도 않는다(main 함수가 없다)
- 스마트 컨트렉트는 멤버 함수를 가지며 가시성을 가진다(public, private, internal, external)
- 따라서 스마트 컨트랙트를 실행시키고 싶으면 정의된 멤버 함수들에 대한 정의가 담긴 **인터페이스**를 알고 있어야 한다.
- 그런데, 바이트코드론 인터페이스를 알 수 없으므로, 스마트 컨트랙트를 배포할 때는 인터페이스 파일도 같이 배포해야 한다.
- 스마트 컨트랙트를 실행하는 트랜젝션은 다음 데이터들을 포함해야 한다
  - 스마트 컨트랙트 어카운트 (= 어떤 스마트 컨트랙트를?)
  - 함수 식별자 (= 스마트 컨트랙트의 어떤 함수를?)
  - 매개변수 ( = 그 함수의 매개변수는?)

#### 4. 배포

- **스마트 컨트랙트**는 <u>바이트코드로 컴파일</u> 되어 **트랜잭션에 담겨** 배포된다
- 위 트랜잭션이 블록에 담기면 그에 따른 새로운 어카운트가 생기는데 이를 CA(Contract Account)라 부른다
- CA는 해당 트랜잭션에 접근이 아능한 어카운트다.
- CA 도 어카운트이므로 이더리움을 전송받아서 잔고를 가질 수 있다. 단, 송금은 함수 실행을 통해 이루어진다
- 반대로 스마트 컨트렉트가 아닌 유저의 어카운트는 EOA(Externally Owned Account) 라고 부른다.
- 스마트 컨트렉트를 최초로 실행하는 어카운트는 언제나 EOA 이다.

#### 5. 코인과 토큰

1. 코인
   - **트랜잭션의** <u>value</u>.
   - **코인의 전송**은, <u>트랜잭션</u>을 통해 이루어진다.
2. 토큰
   - **스마트 컨트랙트의** <u>프로그램 상태</u>.
   - **토큰의 전송**은 <u>스마트 컨트랙트의 함수 실행</u>을 통해 이루어진다.
   - 스마트 컨트랙트에 코인을 전송하고, 토큰의 상태가 나의 어카운트에 매핑되는 것이 ICO 이다.

### 2. ERC-20 토큰

#### 1. ERC-20 토큰

- 이더리움 블록체인으로 새로운 디지털 자산을 만들어내는 방법 중에 하나
- 디지털 자산 중에서 특히 화폐로 쓰이는 토큰을 만들기 위한 표준을 정의한 것이 eRC-20 표준
- ERC-20은 이더리움 스마트 컨트랙트로 새로운 화폐를 발행할 때 구현해야 하는 함수 인터페이스를 정의해 두었따
- 앞서 트랜잭션을 보내어 함수를 실행하려면 그 스마트 컨트랙트의 함수 인터페이션을 알아야 한다고 얘기를 했었는데 만약 그 스마트 컨트랙트 ERC-20 표준을 따른다면 이미 인터페이스를 알고 있으므로 인터페이스를 새로 받아올 필요가 없다
- 이더리움 위에서 토큰을 발행하면 토큰의 전송의 수수료로 이더리움이 필요하므로 계송해서 ERC-20 토큰의 형태를 유지하면서 화폐를 전송하는 것은 좋은 방법이 아니다(아직까지도 반드시 이더리움을 거쳐야 한다.)
- 주로 TokenSale 스마트 컨트래트로 eRC-20 혀태의 토큰을 발행하여 ICo를 진행하는데 사용한다
- 이후에 자체 코인을 기축 통화로 하는 메인 블록체인을 만들고 이더리움의 어느 한 블록을 선정하여 스냅샷을 찍는다. 그때 스마트 컨트랙트의 상태를 보고 메인체인에서 에어드랍을 진행함으로써 토큰은 수명이 끝나게 된다.

### 3. 분산 어플리케이션

#### 특징 및 기술적 한계점

- 분산 어플리케이션은 한개 혹은 여러개의 스마트 컨트랙트로 구성되어 있다.
- 스마트 컨트랙트의 바이트코드가 블록체인 상에 공개되어 있고, 원래 코드가 공개되어 있지만 컴파일하여 서로 같은지 확인할 수 있으므로 프로그램 실행의 유효성을 보장하고 싶을 때 사용할 수 있다
- 랜덤 확률 알고리즘이 공개되어 공정하게 실행되는 것을 보장하는 것이 중요한 도박, 게임 등이 주로 구현되어 있다
- 블록체인은 응답 시간이 느리고 실행결과가 특정한 블록에 기록되므로 분산 어플리케이션은 현재 기술 수준에서 순수하게 블록체인만 백엔드로 사용할 수는 없다
- 결국 백엔드로 블록 체인을 사용하면서 또 따로 블록체인에서 특정한 스마트 컨트랙트들의 실행 결과를 지속적으로 관찰하고 기록하는 서버가 필요하기 때문에 굉장히 비효율적인 형태로 서비스가 구현되고 있다
- 이러한 문제를 해결할 수 있는 연구가 필요한데 다른 많은 문제들에 밀려 연구가 되지 않고 있다.
- ![image-20181025160443723](/Users/lawrence/Library/Application Support/typora-user-images/image-20181025160443723.png)



## Session 3. 

Token : 이더리움 블록체인 네트워크에서 발행되는 디지털 자산

ERC : 이더리움 블록체인 네트워크에서 발행되는 토큰의 표준

ERC-20 : 암호화폐를 발행하기 위한 토큰 표준 (ex: EOS)

ERC-721 : 수집품을 발행하기 위한 토큰 표준 (ex: 크립토키티 고양이)

### 1. 크립토키티

#### 크립토키티의 소스코드를 분석해야 하는 이유

- 대중들이 사용할 수 있는 첫번째 이더리움 분산 어플리케이션
- 스마트 컨트랙트를 작성할 떄 고려해야 할 여러가지 상황에 대한 고민이 담겨 있따
- 크립토키티가 사용한 여러가지 테크닉들을 분석하면 큰 시해ㅇ착오를 겪지 않고 분산 어플리케이션을 작성할 수 있을 것이다
- 게다가 주석도 자세하게 달려 있어서 스마트 컨트랙트 의 모범 답안이라고 볼 수 있다.



#### 크립토키티의 소스코드를 통해 배울 수 있는 것들

- 블록체인 네트워크에 대한 이해
  - 블록체인에서 시간 개념은 어떻게 구현할 수 있는가?
  - 블록체인에서 데몬을 구현할 수 있는가?
  - 블록체인에서 요청에 대한 응답을 받는 방법은 무엇인가?
- 스마트 컨트렉트에 대한 이해
  - 스마트 컨트랙트 코드를 업데이트 할 수는 없는가?
  - 스마트 컨트렉트에 트랜잭션을 보내는 계정에 권한을 설정할 수 있는가?



##### > 블록체인에서 시간 개념을 어떻게 구현할 수 있는가?

고양이끼리 교배시킨 뒤 새끼고양이가 태어나기까지는 지정된 시간이 필요하다.

​	—> 블록 생성 시간을 지정함으로써 구현.

- 단, 해당 시간이 지난 후 블럭이 생성되는 것이 아닌, 

- 시간이 지난 후 새로운 트랜잭션을 만들어야 함. (why? 데몬이 아니니까!)

##### > 블록체인에서 데몬을 구현할 수 있는가?

- 크립토키티에서 새끼 고양이가 태어날 블록에 도달했다고 해서 자동적으로 태어나지 않는다.
  - if) 서버-클라이언트 모델 => 데몬이 giveBirth 함수를 자동 호출
  - but, 스마트 컨트랙트는 데몬처럼 항상 실행되고 있지 않고, 트랜잭션이 블록에 담길 떄 그 트랜잭션이 호출된 함수만 수행된다.
- 누군가가 새끼가 태어나도록 giveBirth 함수를 호출하는 트랜잭션을 발생시켜야 한다.
  - ==> 트랜잭션의 수수료는 사용자가 부담함

##### > 블록체인에서 요청에 대한 응답을 받는 방법은 무엇인가?

- 블록체인은 함수 호출이 끝난 뒤에 응답을 주는 것이 불가능 하다

  > 블록체인에서는 모든 노드가 같은 일을 수행한다
  >
  > 만약에 100개의 노드가 응답을 주는 함수를 호출한다면 응답을 받는 노드는 100개의 응답을 받게 될것
  >
  > 함수가 실행되는 시점은 블록이 만들어지고 있는 시점인데다가 합의도 이루어지지 않은 상태이기 때문에 
  >
  > ​	아직 유효한 응답이 아니다

- 이벤트와 영수증

  > 이더리움은 외부에 함수 호출 결과를 알리기 위해 함수를 사용한다
  >
  > 블록이 만들어지면서 이벤트가 호출되면 그 결과값을 블록의 로그 영역에 영수증으로 기록함
  >
  > 어떤 이벤트 호출의 결과를 알고 싶으면 
  >
  > ​	풀 노드에서 해당 이벤트가 호출된 블록을 가져온 뒤 영수증을 찾으면 된다
  >
  > 데몬처럼 구현하고 싶으면 서버에서 계속해서 블록의 로그 영역을 지켜보게 하면 된다.

##### > 스마트 컨트랙트 코드를 업데이트 할 수는 없는가?

- 스마트 컨트랙트를 분리시킴으로써 가능하다.

  > 한번 블록체인에 배포된 스마트 컨트랙트의 코드는 수정/삭제가 불가능하다
  >
  > 하지만 스마트 컨트렉트의 프로그램 상태는 업데이트 할 수 있다
  >
  > 스마트 컨트렉트의 프로그램 변수에 업데이트 가능성이 있는 다른 컨트렉트의 주소를 대입하고 그 변수를 통해 다른 컨트랙트 인스턴스를 만들고 코드를 사용하는 방식으로 코드를 작성한다면 새로운 컨트랙트를 배포하고 변수 값을 업데이터 하는 방식으로코드 업데이트가 가능하다.

##### > 스마트 컨트렉트에 트랜잭션을 보내는 계정에 권한을 설정할 수 있는가?

- C Level Access Control(CEO, CFO, COO)

  > c 언어의 assert와 비슷한 역할을 하는 require문을 이용해서 C level Access Control을 수행
  >
  > 컨트랙트를 배포할 떄 불리는 생성자에 CEO, CFO, COO 주소를 각 변수에 대입
  >
  > Modifier(python의 decorator와 유사)로 만들어서 다른 함수에 상속시켜 코드를 재사용

## Session 4. 논문 분석을 통한 블록체인 기술 현황

### 1. TPS 측정 방법이 합리적인가?

배경: TPS를 너무 과신한다. 우린 TPS 몇이다. 만 자랑한다. 그런데 TPS를 어떻게 측정하는지 조차 감이 안오는 상황이다.

#### EOS 흑역사

WASM 속도 재듯이 해놓고 5만이라고 뻥까서 박제댐 ㅋ



### 2. 용어 정리

#### 1. TPS (Transaction Per Second)

1. 컴퓨터 공학적 정의
2. - 확장성이란, 어떤 시스템이나 네트워크, 혹은 프로세스가 수행 중에 증가하는 작업량으로 인한 부하를 ㄱ마당할 수 있는 능력 혹은 가능성을 의미한다.
   - 반대로 작업량이 감소했을 때, 사용하는 컴퓨팅 자원을 얼마나 효율적으로 줄일 수 있는지도 중요한 문제이다.
   - 예를들어, 쇼핑몰 서비스를 운영하는 웹서버는 특가상품을 판매할 때 급증하는 요청ㅇ량을 감당할 수 있어야 하며, 반대로 요청량이 감소했을 때 그에 맞게 리소스 사용량을 줄여야 한다.
3. 블록체인에서의 정의
   - 트랜잭션의 발생량이 증ㄱ하ㅐㅆ을 때 그에 맞게 TPS도 함꼐 증가하여 트랜잭션의 평균적인 승인 사근을 유지할 숭 ㅣㅆ는가?

#### 2. 일관성

1. 한 번 정해진 트랜잭션의 순서가 뒤바뀌지 않는 정도
   - 일정 수준 이상으로 일관성이 지켜지지 않는다면
     - 블록에 담겨 컨펌이 된 트랜잭션에 대한 신뢰가 낮아짐
2. 일관성이 깨지는 경우



## 3. 블록체인 코어 프로토콜 설계의 목표

### 1. 배경지식

#### 1. 이중 지불 공격 (Double Spending Attack)

- 구매자가 판매자에게 디지털 자산을 송금하는 트랜잭션을 발생시키고, 판매자 몰래 네트워크에 해당 트랜잭션과 양립할 수 없는 모순된 트랜잭션을 발생시킴으로써 판매자에게 자산을 보내는 트랜잭션을 무효화 시키는 공격
- 이중 지불 공격으로 판매자는 디지털 자산을 잃을 위험이 있으므로, 송금 트랜잭션 뒤에 충분한 블록이 붙어서 블록 체인의 reorganization이 발생하기 힘들어질 때까지 기다려야 한다
- 공격에 필요한 비용이있으므로 소액 결제에 대해서는 위와 같은 공격을 잘 하지 않을 것이라고 가정하고 충분히 컨펌되지 않아도 결제가 이루어졌다고 가정하는 경우도 있다

#### 2. 이기적 채굴 (Selfish Mining)

- 작업 증명 알고리즘을 합의 알고리즘으로 사용하는 블록체인에서 채굴자는 매 라운드마다 게임에서 이기기위해 여러가지 전략을 짤 수 있다
- 그중의 하나가 이기적 채굴이라는 방법인데, 블록 생성에 성공하고 나서 이를 주변에 전파하지 않고 곧이어 다음 블록을 채굴하는 것
- 그러면 다음 블록에 대한 채굴을 남들보다 먼저 시작하고 있을 확률이 크므로 충분한 해시 파워를 가지고 있다는 가정 하에 다음 블록도 먼저 찾을 확률이 커진다
- 그러다 퍼블릭 블록체인이 이기적 채굴자의 블록 높이를 따라잡게 되면 블록들을 전파시켜 리워드를 독식한다

#### 3. 이클립스 공격 (Eclipse Attack)

- 게이트웨이나 dns 서버등을 해킹하면 특정한 노드들을 네트워크적으로 고립시킬 수 있다
- 고립시킨다는 뜻은 퍼블릭 블록체인의 정보를 가리고 내가 보여주고 싶은 정보만 보여주는 것이다
- 공유기를 해킹해서 피싱 사이트를 보여주는 것과 유사하다
- 고립시킨 노드들의 해시파워를 이용해서 이기적 채굴이나 의도적인 포크 등 공격에 이용할 수 있다.



### 2. 일관성과 확장성

목표 : 일관성을 어느 수준 이상으로 지키면서 상황에 따라 TPS가 확장성을 가지고 유동적으로 변할 수 있도록 해야한다.

#### 1) 일관성을 어느 수준 이상으로 지킬 수 있도록 프로토콜 설계

##### 1. 자연적인 포크가 자주 발생하지 않도록 프로토콜을 설계

- 어떤 트랜잭션들을 만들었을 때, 이 트랜잭션들이 충분히 전파(99%)되기 전에 새로운 블럭이 만들어지지 않도록 설계.
  - **네트워크가 반드시 있어야지만 TPS 이야기가 가능함. (그러나 블록이 생성되는 중엔 네트워크가…아님...)**
    - **=> TPS가 그렇게 의미가 있을…까?**

##### 2. 공격에 의한 포크를 방어할 수 있도록 프로토콜을 설계

- 트랜잭션 순서를 바꾸는 공격은 주로 순서를 결정하는 권한을 가진 Miner에 의해 발생한다.

  - 이중 지불 공격
  - 이기적인 채굴

      - 이클립스 공격

- 마이너가 공격할 유인(Incentive)을 최대한 줄여야 한다.

  - 공격을 위해 사용되는 마이닝 비용을 공격을 통해 얻을 수 있는 이득보다 크게 만들어야 한다
  - **네트워크 전파 속도에 영향을 크게 받음 (빠를 수록 안전하짐)**
  - 블록 난이도와 전체 마이닝 파워 및 공격자의 마이닝 파워, 버려지는 블록 비율, 네트워크 파티셔닝 등 굉장히 많은 변수가 존재 

**블록체인은 TPS보다, 네트워크가 매우매우 중요하다. 네트워크에 따라 많은 것이 달라진다…** 

#### 2) TPS가 확장성을 가지고 유동적으로 변할 수 있도록 프로토콜을 설계

##### 1. 요청량이 늘어날 때 무엇을 투입하거나 바꾸면 TPS를 높일 수 있을까?

**확장성 문제의 해결을 위한 아이디어**

> 1. 샤딩 : 네트워크를 나누어 각각 순서를 정하고 합침.
> 2. 사이드 체인 : 소규모 네트워크를 만들어 따로 순서를 정하고 합침.
> 3. 스테이트 채널 : 두 노드가 독립적인 네트워크를 만들어서 따로 순서를 정하고 합침.

##### 2. 요청량이 줄어들 때 무엇을 빼거나 바꾸면 TPS를 높일 수 있을까?

  - 쪼개었던 네트워크를 다시 합쳐서 네트워크의 수를 줄여야 한다
  - 그런데 이미 성능이 너무 느리기 때문에 이것을 고민하는 것은 시기 상조이다.





